<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script type="text/javascript">
	function ajaxGet(){
		const xhr=new XMLHttpRequest();
		
		let params="num=1&id=hk";
		
		//      (요청방식, 요청주소, 비동기여부)
		xhr.open("GET","data.json?"+params,true);
		
		xhr.onreadystatechange=function(){
			if(xhr.readyState===4 && xhr.status === 200){
				let data=JSON.parse(xhr.responseText);//JS객체로 변환
				console.log(data.id,data.name);
				
				document.querySelector("#result").innerHTML=
										`<p>${data.id}<p>`
										+`<p>${data.name}<p>`
										+`<p>${data.addr}</p>`;
		
			}
		}
		
		//요청을 서버로 전송
		xhr.send();
	}
	// 서버 통신을 통해 받아온 결과를 가지고 또 다른 요청 처리
	// -> 콜백함수: 함수가 종료되면 바로 다음 함수 호출하는 방식
	//          콜백함수의 지옥
	/* getUser(id){
			const userinfo=data;
			getBoard(userinfo.id);//사용자의 게시글 가져오기
			
				getTest(board.id);//특정글 가져오기
	   }
	*/
	
	// promise 객체
	//  여러 ajax처리 작업을 연결하다면 콜백함수를 많이 써야 되는 경우 생김
	//  -> 콜백함수를 해결하고, 비동기 작업의 성공/실패를 깔끔하게 처리하는 객체
	function promiseTest(method, url, data=null){
		return new Promise((resolve,reject)=>{
			const xhr=new XMLHttpRequest();
			const params="num=1&id=hk";
			xhr.open(method,url,true);
			xhr.onreadystatechange=function(){
				if(xhr.readyState===4){
					if(xhr.status>=200 && xhr.status < 300){
						//응답 데이터를 처리
						resolve(xhr.responseText);
					}else{
						//요청 실패에 대한 처리
						reject(new Error("요청실패:"+xhr.status));
					}
				}
			};
			
			xhr.send();//전송 실행
			
		});
	}
	
	//promise 사용
	function ajaxPromise(){
		promiseTest("GET","data.json")
					.then((response)=>{
						const data=JSON.parse(response);
						console.log(data);
					})
					.catch(error=>{
						console.error("실패:"+error);
					})
	}
	
	// promise기반의 ajax처리 API 
	// fetch() 등장~~
	fetch('data.json').then(response=>{
		
					}).then(str=>{
						
					}).catch(error=>{
						console.log("실패;",error);
					});
</script>
</head>
<body>
<button onclick="ajaxGet()">Get방식</button>
<div id="result"></div>
</body>
</html>



